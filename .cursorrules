# ACME Integrations Cursor Rules

You are an expert TypeScript developer working on the ACME Integrations monorepo. This project builds integrations using the ACME integration framework with a focus on type safety, clean architecture, and developer experience.

## Project Context

**Technology Stack:**

- **Turbo**: Build orchestration and dependency management
- **Bun**: Package manager and runtime
- **TypeScript**: Strict type checking and modern ES features
- **Valibot**: Runtime schema validation and type inference
- **ESLint + Prettier**: Code quality and consistent formatting

**Architecture:**

- **Nodes**: Trigger (webhooks/polling), Callable (on-demand), Pure (stateless)
- **Pins**: Type-safe data definitions with runtime validation
- **Controls**: UI components (Text, Expression, Select, Switch)
- **Environment**: Secure configuration management
- **Webhooks**: HTTP endpoints for external triggers

## Critical Coding Standards

### TypeScript Excellence

```typescript
// ✅ Inline type specifiers (NOT top-level type imports)
import { createClient, type ApiResponse } from 'lib';

// ✅ Proper typing over v.any()
export const item = i.pins.data<UserType>({
  description: 'A user object.',
});

// ✅ Investigate library types in /node_modules/[lib-name]/ instead of workarounds
// Check actual type definitions before using any, conditional spreads, or type assertions
```

### Pin Development (CRITICAL RULES)

**Naming Conventions:**

```typescript
// ✅ NEVER prefix exports with category names
export const address; // NOT emailAddress
export const item; // NOT user (avoid pins.user.user)
export const list; // NOT users

// ✅ Standard naming patterns
// - item: single entities (pins.user.item, pins.file.item)
// - list: arrays/collections (pins.user.list, pins.file.list)
// - properties: specific fields (pins.user.id, pins.file.name)
```

**Pin Definition Rules:**

```typescript
// ✅ Non-optional by default, handle optionality at usage
export const flag = i.pins.data({
  description: 'A boolean flag.',
  control: i.controls.switch(),
  schema: v.boolean(),
});

// Usage: pins.common.flag.with({ optional: true })

// ✅ Control property rules
// - New pins: omit control (defaults to no control)
// - Only use control: false when extending pins that have controls
```

### Node Implementation Standards

**Direct Property Passing (MANDATORY):**

```typescript
// ✅ Pass inputs directly - no conditional spreads
const response = await api.call({
  field: opts.inputs.field,
  optional: opts.inputs.optional, // API handles undefined
});

// ❌ NEVER use conditional spreads
// ...(opts.inputs.optional && { optional: opts.inputs.optional })
```

**Semantic Outputs (CRITICAL):**

```typescript
// ✅ Return specific data matching node purpose
export const listFiles = i.nodes.callable({
  outputs: {
    files: pins.file.list.with<FileType[]>({
      // MUST specify type
      description: 'Array of files.',
    }),
  },
  async run(opts) {
    const response = await api.files.list();
    return opts.next({ files: response.files ?? [] }); // Extract data
  },
});

// ❌ NEVER return full API responses
// return opts.next({ response }); // Users must navigate response.files
```

**Output Type Safety (MANDATORY):**

```typescript
// ✅ Every output pin MUST have a TypeScript type
outputs: {
  user: pins.user.item.with<UserInfoResponse['user']>({
    description: 'User information.',
  }),
}

// ❌ Missing type specification
outputs: {
  user: pins.user.item.with({
    description: 'User information.',
  }),
}
```

## Task-Specific Guidelines

### Adding New Nodes

1. **Location**: `src/nodes/[category]/[category].ts`
2. **Exports**: Update `src/nodes/[category]/index.ts` and `src/nodes/index.ts`
3. **Pin Priority**: Required → Optional → Advanced
4. **Outputs**: Semantic data (files: File[]) not API responses

### Creating Pins

1. **Location**: `src/pins/[category].ts`
2. **Export**: Update `src/pins/index.ts`
3. **Naming**: No category prefixes, use item/list/properties
4. **Schemas**: Simple types get v.schema(), complex types get TypeScript generics
5. **Controls**: Only for user input pins, not API response pins

### Environment Setup

1. **Definition**: Add to integration `env` object with controls
2. **Validation**: Use valibot schemas
3. **Security**: Mark sensitive with `sensitive: true`
4. **Initialization**: Set up clients in `start()` function

### Error Handling

1. **API Errors**: Handle with descriptive messages and context
2. **Validation**: Use proper error types from libraries
3. **User Feedback**: Return meaningful error information

## Integration Development Checklist

**Before Implementation:**

- [ ] Official Node.js client exists and is used
- [ ] Official documentation reviewed (check for deprecated fields)
- [ ] Pin names follow conventions (no prefixes, use item/list)
- [ ] TypeScript types imported with inline `type` specifiers
- [ ] Library types investigated before creating workarounds

**During Implementation:**

- [ ] Direct property passing (no conditional spreads)
- [ ] Shared state usage (opts.state.client, opts.state.session)
- [ ] Semantic outputs (extract specific data, not full responses)
- [ ] Type safety (every output pin has TypeScript type)
- [ ] Pin priorities ordered correctly (required → optional → advanced)

**After Implementation:**

- [ ] Error handling comprehensive and user-friendly
- [ ] No generic response pins (slackResponse, apiResponse)
- [ ] Operations without meaningful data have no outputs
- [ ] Arrays use fallbacks (response.files ?? [])

## File Structure Patterns

```
integrations/[name]/
├── src/
│   ├── index.ts              # Integration entry + client setup
│   ├── nodes/
│   │   ├── [category]/
│   │   │   ├── [category].ts # Node implementations
│   │   │   └── index.ts      # Category exports
│   │   └── index.ts          # All nodes export
│   └── pins/
│       ├── [category].ts     # Pin definitions by category
│       └── index.ts          # All pins export
├── images/icon.png           # Integration icon
├── package.json
├── tsconfig.json
└── eslint.config.mjs
```

## Common Anti-Patterns to Avoid

```typescript
// ❌ Top-level type imports
import type { ApiResponse } from 'lib';

// ❌ Category name prefixes
export const emailAddress;

// ❌ Conditional spreads
...(input && { field: input })

// ❌ Intermediate variables
const params = { field: input };
api.call(params);

// ❌ Full API responses
return opts.next({ response });

// ❌ Generic response pins
pins.slack.slackResponse

// ❌ Missing output types
outputs: { user: pins.user.item.with({ description: '...' }) }
```

## Quick Reference

**Pin Naming**: `item` (single), `list` (array), `[property]` (field)
**Direct Passing**: `api.call({ field: opts.inputs.field })`
**Semantic Outputs**: `{ files: response.files ?? [] }`
**Type Safety**: `.with<Type>({ description: '...' })`
**Priority Order**: Required → Optional → Advanced
